#!/bin/bash

# Colores para formato
COLOR1="\033[1;36m"  # Cyan
COLOR_SSH="\033[0;33m"  # Amarillo
COLOR_VPN="\033[0;32m"  # Verde
NC="\033[0m"  # Sin color

# Funciones de formato
msg_bar() {
    echo -e "${COLOR1}┌─────────────────────────────────────────────────┐${NC}"
}

msg_tit() {
    echo -e "${COLOR1}│                USUARIOS EN LÍNEA                │${NC}"
}

msg_center() {
    local text="$1"
    local width=49
    local padding=$(( (width - ${#text}) / 2 ))
    printf "${COLOR1}│%*s%s%*s│${NC}\n" $padding "" "$text" $padding ""
}

msg_prompt() {
    local text="$1"
    echo -e "${COLOR1}${text}${NC}"
}

# Limpieza de archivos temporales al salir
cleanup() {
    rm -f /tmp/ssh2 /tmp/log-db.txt /tmp/log-db-pid.txt /tmp/vpn-login-tcp.txt /tmp/vpn-login-udp.txt /tmp/auth.log
}
trap cleanup EXIT

# Función principal
function cek() {
    clear

    # Configuración inicial
    TIMES="10"  # No usado, mantenido por compatibilidad
    CHATID=$(cat /etc/per/id 2>/dev/null || echo "")
    KEY=$(cat /etc/per/token 2>/dev/null || echo "")
    URL="https://api.telegram.org/bot$KEY/sendMessage"
    ISP=$(cat /etc/xray/isp 2>/dev/null || echo "Desconocido")
    CITY=$(cat /etc/xray/city 2>/dev/null || echo "Desconocido")
    domain=$(cat /etc/xray/domain 2>/dev/null || echo "Desconocido")
    author=$(cat /etc/profil 2>/dev/null || echo "Desconocido")
    MAX_CONNECTIONS=2  # Límite de conexiones por usuario
    LOG_DIR="/var/log/cek"
    mkdir -p "$LOG_DIR" 2>/dev/null

    # Validar servicios
    for service in dropbear sshd; do
        if ! systemctl is-active -q "$service" 2>/dev/null; then
            echo -e "${COLOR1}Advertencia: $service no está corriendo.${NC}"
        fi
    done
    # Verificar OpenVPN solo si los logs existen
    openvpn_active=false
    if [ -f "/etc/openvpn/server/openvpn-tcp.log" ] || [ -f "/etc/openvpn/server/openvpn-udp.log" ]; then
        openvpn_active=true
        if ! systemctl is-active -q openvpn@server 2>/dev/null; then
            echo -e "${COLOR1}Advertencia: openvpn@server no está corriendo.${NC}"
        fi
    fi

    # Validar archivo de log
    if [ -f "/var/log/auth.log" ]; then
        LOG="/var/log/auth.log"
    else
        journalctl -u sshd -u dropbear --since "1 hour ago" > /tmp/auth.log 2>/dev/null
        LOG="/tmp/auth.log"
        if [ ! -s "$LOG" ]; then
            echo -e "${COLOR1}Error: No se encontraron logs de autenticación.${NC}"
            read -n 1 -s -r -p "$(msg_prompt " Presione cualquier tecla para continuar...")"
            return 1
        fi
    fi

    # Reiniciar ws-stunnel si está activo
    if systemctl is-active -q ws-stunnel 2>/dev/null; then
        systemctl restart ws-stunnel > /dev/null 2>&1
        sleep 3
    fi

    # Obtener usuarios del sistema
    declare -A jumlah pid
    cat /etc/passwd | grep "/home/" | cut -d":" -f1 > /etc/user.txt
    mapfile -t username < /etc/user.txt
    for user in "${username[@]}"; do
        jumlah[$user]=0
        pid[$user]=""
    done

    # Inicializar archivo de conexiones
    : > /tmp/ssh2

    # Monitoreo de SSH (Dropbear y OpenSSH)
    msg_bar
    msg_tit
    msg_center "• SSH USUARIOS EN LÍNEA •"
    msg_bar
    printf "${COLOR_SSH}%-20s %-15s %-20s %-15s %-10s${NC}\n" "Usuario" "Protocolo" "IP" "Tiempo" "Recursos"
    echo -e "${COLOR_SSH}---------------------------------------------------------------${NC}"

    # Usar 'who' para sesiones activas
    ssh_count=0
    while read -r user tty ip time; do
        # Limpiar IP (quitar paréntesis)
        ip=$(echo "$ip" | tr -d '()')
        if [ -z "$user" ] || [ -z "$ip" ]; then
            continue
        fi

        # Determinar protocolo
        proto="Unknown"
        proc_pid=$(pgrep -u "$user" sshd 2>/dev/null)
        if [ -n "$proc_pid" ]; then
            proto="sshd"
        else
            proc_pid=$(pgrep -u "$user" dropbear 2>/dev/null)
            if [ -n "$proc_pid" ]; then
                proto="dropbear"
            fi
        fi

        # Calcular duración
        login_time=$(date -d "$time" +%s 2>/dev/null || echo 0)
        current_time=$(date +%s)
        duration=$(( (current_time - login_time) / 60 ))
        if [ "$duration" -lt 0 ]; then
            duration=0
        fi

        # Obtener uso de recursos
        cpu_mem="N/A"
        if [ -n "$proc_pid" ]; then
            # Tomar el primer PID si hay varios
            first_pid=$(echo "$proc_pid" | head -n 1)
            cpu_mem=$(ps -p "$first_pid" -o %cpu,%mem --no-headers 2>/dev/null)
            if [ -n "$cpu_mem" ]; then
                cpu_mem="${cpu_mem%% *}%/${cpu_mem##* }%"
            else
                cpu_mem="N/A"
            fi
        fi

        # Guardar conexión
        echo "$user $proto $ip $duration min $cpu_mem" >> /tmp/ssh2

        # Actualizar contadores
        if [[ -n "${jumlah[$user]}" ]]; then
            jumlah[$user]=$((jumlah[$user] + 1))
            pid[$user]+="$proc_pid "
        fi

        # Mostrar en pantalla
        printf "${COLOR_SSH}%-20s %-15s %-20s %-15s %-10s${NC}\n" "$user" "$proto" "$ip" "$duration min" "$cpu_mem"
        ssh_count=$((ssh_count + 1))
    done < <(who | awk '{print $1, $2, $5, $3}' | grep -v '^$' | sort -u)

    if [ "$ssh_count" -eq 0 ]; then
        echo -e "${COLOR_SSH}No hay usuarios SSH conectados.${NC}"
    fi

    # Verificar límites de conexiones
    for user in "${!jumlah[@]}"; do
        if [[ ${jumlah[$user]} -gt $MAX_CONNECTIONS ]]; then
            echo -e "${COLOR1}¡Advertencia! $user tiene ${jumlah[$user]} conexiones (límite: $MAX_CONNECTIONS)${NC}"
        fi
    done

    # Monitoreo de OpenVPN
    tcp_count=0
    udp_count=0
    if [ "$openvpn_active" = true ]; then
        msg_bar
        msg_center "• OPENVPN USUARIOS EN LÍNEA •"
        msg_bar

        # OpenVPN TCP
        if [ -f "/etc/openvpn/server/openvpn-tcp.log" ]; then
            echo -e "${COLOR_VPN}OpenVPN TCP:${NC}"
            printf "${COLOR_VPN}%-20s %-20s %-20s${NC}\n" "Usuario" "IP Real" "IP Virtual"
            echo -e "${COLOR_VPN}---------------------------------------------------${NC}"
            if [ ! -f "/tmp/vpn-login-tcp.txt" ] || [ "$(find /tmp/vpn-login-tcp.txt -mmin +5 2>/dev/null)" ]; then
                grep -w "^CLIENT_LIST" /etc/openvpn/server/openvpn-tcp.log | cut -d ',' -f 2,3,8 | sed 's/,/      /g' > /tmp/vpn-login-tcp.txt
            fi
            while read -r user ip_real ip_virt; do
                if [ -n "$user" ]; then
                    printf "${COLOR_VPN}%-20s %-20s %-20s${NC}\n" "$user" "$ip_real" "$ip_virt"
                    tcp_count=$((tcp_count + 1))
                fi
            done < /tmp/vpn-login-tcp.txt
        fi

        # OpenVPN UDP
        if [ -f "/etc/openvpn/server/openvpn-udp.log" ]; then
            echo -e "${COLOR_VPN}OpenVPN UDP:${NC}"
            printf "${COLOR_VPN}%-20s %-20s %-20s${NC}\n" "Usuario" "IP Real" "IP Virtual"
            echo -e "${COLOR_VPN}---------------------------------------------------${NC}"
            if [ ! -f "/tmp/vpn-login-udp.txt" ] || [ "$(find /tmp/vpn-login-udp.txt -mmin +5 2>/dev/null)" ]; then
                grep -w "^CLIENT_LIST" /etc/openvpn/server/openvpn-udp.log | cut -d ',' -f 2,3,8 | sed 's/,/      /g' > /tmp/vpn-login-udp.txt
            fi
            while read -r user ip_real ip_virt; do
                if [ -n "$user" ]; then
                    printf "${COLOR_VPN}%-20s %-20s %-20s${NC}\n" "$user" "$ip_real" "$ip_virt"
                    udp_count=$((udp_count + 1))
                fi
            done < /tmp/vpn-login-udp.txt
        fi
    fi

    # Resumen
    msg_bar
    echo -e "${COLOR1}│ Resumen:${NC}"
    echo -e "${COLOR1}│ Total SSH: $ssh_count${NC}"
    echo -e "${COLOR1}│ Total OpenVPN TCP: $tcp_count${NC}"
    echo -e "${COLOR1}│ Total OpenVPN UDP: $udp_count${NC}"
    msg_bar

    # Guardar historial
    if [ "$ssh_count" -gt 0 ] || [ "$tcp_count" -gt 0 ] || [ "$udp_count" -gt 0 ]; then
        {
            echo "$(date):"
            echo "SSH:"
            cat /tmp/ssh2 2>/dev/null
            echo "OpenVPN TCP:"
            cat /tmp/vpn-login-tcp.txt 2>/dev/null
            echo "OpenVPN UDP:"
            cat /tmp/vpn-login-udp.txt 2>/dev/null
            echo "-----------------------------------"
        } >> "$LOG_DIR/connections_$(date +%F).log"
    fi

    # Enviar a Telegram si está configurado
    if [ -n "$CHATID" ] && [ -n "$KEY" ] && { [ "$ssh_count" -gt 0 ] || [ "$tcp_count" -gt 0 ] || [ "$udp_count" -gt 0 ]; }; then
        output="Usuarios en línea ($ISP, $CITY):\n"
        if [ "$ssh_count" -gt 0 ]; then
            output+="SSH ($ssh_count):\n$(cat /tmp/ssh2 2>/dev/null)\n"
        fi
        if [ "$tcp_count" -gt 0 ]; then
            output+="OpenVPN TCP ($tcp_count):\n$(cat /tmp/vpn-login-tcp.txt 2>/dev/null)\n"
        fi
        if [ "$udp_count" -gt 0 ]; then
            output+="OpenVPN UDP ($udp_count):\n$(cat /tmp/vpn-login-udp.txt 2>/dev/null)"
        fi
        curl -s -X POST "$URL" -d chat_id="$CHATID" -d text="$output" > /dev/null 2>&1
    fi

    # Pausa y retorno al menú
    read -n 1 -s -r -p "$(msg_prompt " Presione cualquier tecla para continuar...")"
    m-sshovpn  # Asumo que esto es una función externa
}

# Ejecutar la función
cek
