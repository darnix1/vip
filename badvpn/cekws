#!/usr/bin/python3
import os
import re
import subprocess
import json
import pandas as pd
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.box import SIMPLE
from rich.style import Style
from rich.progress import Progress
from datetime import datetime
import time

# Configuración
APISERVER = "127.0.0.1:10000"
XRAY_PATH = "/etc/xray/config.json"
XRAY_BIN = "/usr/local/bin/xray"  # Asegúrate de que esta es la ruta correcta
REFRESH_SECONDS = 2  # Intervalo de actualización en segundos

# Inicializar Rich Console
console = Console()

# Funciones de conversión
def tim2sec(time_str):
    """Convierte formato HH:MM:SS a segundos"""
    parts = list(map(int, time_str.split(":")))
    seconds = 0
    for i, part in enumerate(reversed(parts)):
        seconds += part * (60 ** i)
    return seconds

def human_readable_size(size):
    """Convierte bytes a formato legible (B, KB, MB, GB)"""
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size < 1024:
            return f"{size:.2f} {unit}"
        size /= 1024

def get_vmess_users():
    """Obtiene la lista de usuarios VMESS del archivo de configuración"""
    vm_users = []
    try:
        with open(XRAY_PATH, "r") as config_file:
            for line in config_file:
                match = re.search(r"^#vmg\s+(\S+)", line)
                if match:
                    vm_users.append(match.group(1))
    except FileNotFoundError:
        console.print(f"[red]Error: No se pudo encontrar el archivo de configuración en {XRAY_PATH}[/red]")
    return vm_users

def get_active_connections():
    """Obtiene conexiones activas desde el log de acceso"""
    active_users = set()
    vm_users = get_vmess_users()
    
    try:
        with open("/var/log/xray/access.log", "r") as log_file:
            log_lines = log_file.readlines()[-100:]  # Últimas 100 líneas
            
        for line in log_lines:
            parts = line.split()
            if len(parts) >= 7:
                user = parts[6]
                time_str = parts[1]
                ip = parts[2]
                
                if "email:" in user:
                    user_email = user.split("email:")[1].strip()
                    if user_email in vm_users:
                        now = tim2sec(datetime.now().strftime("%H:%M:%S"))
                        conn_time = tim2sec(time_str)
                        time_diff = now - conn_time
                        
                        if time_diff < 40:  # Conexión activa si es menor a 40 segundos
                            clean_ip = re.sub(r"tcp://", "", ip).split(".")[0:3]
                            clean_ip = ".".join(clean_ip)
                            active_users.add((user_email, clean_ip))
    except FileNotFoundError:
        console.print("[red]Error: No se pudo leer el archivo de logs[/red]")
    
    return active_users

def get_real_time_stats():
    """Obtiene estadísticas en tiempo real desde Xray API"""
    try:
        result = subprocess.run(
            [XRAY_BIN, "api", "statsquery", "--server", APISERVER],
            capture_output=True, 
            text=True
        )
        
        data = json.loads(result.stdout)
        stats = []
        for item in data.get('stat', []):
            if "name" in item and "value" in item:
                parts = item["name"].split(">>>")
                if len(parts) > 3 and parts[0] == "user":
                    stats.append({
                        "user": parts[1],
                        "type": parts[3],  # uplink/downlink
                        "value": int(item["value"])
                    })
        return stats
    except (json.JSONDecodeError, subprocess.SubprocessError) as e:
        console.print(f"[red]Error al obtener estadísticas: {str(e)}[/red]")
        return []

def get_user_limits(user):
    """Obtiene el límite y uso actual de un usuario"""
    try:
        with open(f"/etc/limit/vmess/{user}", "r") as usage_file:
            usage = int(usage_file.read().strip())
        
        with open(f"/etc/vmess/{user}", "r") as limit_file:
            limit = int(limit_file.read().strip())
        
        return usage, limit
    except FileNotFoundError:
        return 0, 0

def display_combined_stats():
    """Muestra estadísticas combinadas de conexiones y tráfico"""
    with Progress(transient=True) as progress:
        task = progress.add_task("[cyan]Monitoreo en tiempo real...", total=None)
        
        while True:
            try:
                # Obtener datos
                active_conns = get_active_connections()
                stats = get_real_time_stats()
                
                # Procesar conexiones activas
                active_users = {}
                for user, ip in active_conns:
                    if user not in active_users:
                        active_users[user] = {"ips": set(), "count": 0}
                    active_users[user]["ips"].add(ip)
                    active_users[user]["count"] += 1
                
                # Procesar estadísticas de tráfico
                df = pd.DataFrame(stats)
                traffic_data = {}
                
                if not df.empty:
                    downlink = df[df['type'] == 'downlink'].groupby('user')['value'].sum()
                    uplink = df[df['type'] == 'uplink'].groupby('user')['value'].sum()
                    
                    for user in set(downlink.index) | set(uplink.index):
                        traffic_data[user] = {
                            "down": downlink.get(user, 0),
                            "up": uplink.get(user, 0),
                            "total": downlink.get(user, 0) + uplink.get(user, 0)
                        }
                
                # Combinar datos
                all_users = set(active_users.keys()) | set(traffic_data.keys())
                combined_data = []
                
                for user in all_users:
                    usage, limit = get_user_limits(user)
                    combined_data.append({
                        "user": user,
                        "connections": active_users.get(user, {}).get("count", 0),
                        "ips": ", ".join(active_users.get(user, {}).get("ips", [])),
                        "down": traffic_data.get(user, {}).get("down", 0),
                        "up": traffic_data.get(user, {}).get("up", 0),
                        "total": traffic_data.get(user, {}).get("total", 0),
                        "usage": usage,
                        "limit": limit,
                        "remaining": limit - usage if limit > 0 else 0
                    })
                
                # Ordenar por tráfico total descendente
                combined_data.sort(key=lambda x: x["total"], reverse=True)
                
                # Limpiar consola y mostrar nueva tabla
                console.clear()
                console.print(Panel("[bold cyan]• VMESS USER MONITOR •[/bold cyan]", style="cyan", box=SIMPLE))
                
                table = Table(
                    show_header=True,
                    header_style=Style(bold=True, color="blue"),
                    box=SIMPLE
                )
                
                # Columnas de la tabla
                table.add_column("Usuario", style="cyan")
                table.add_column("Conexiones", justify="center", style="magenta")
                table.add_column("IPs", style="dim")
                table.add_column("↓ Descarga", justify="right", style="green")
                table.add_column("↑ Subida", justify="right", style="magenta")
                table.add_column("Total", justify="right", style="bold yellow")
                table.add_column("Uso/Límite", justify="right", style="bold")
                table.add_column("Restante", justify="right", style="bold green")
                
                # Agregar filas
                for user_data in combined_data:
                    usage_pct = (user_data["usage"] / user_data["limit"]) * 100 if user_data["limit"] > 0 else 0
                    usage_str = (f"{human_readable_size(user_data['usage'])} / "
                                f"{human_readable_size(user_data['limit'])} "
                                f"({usage_pct:.1f}%)")
                    
                    table.add_row(
                        user_data["user"],
                        str(user_data["connections"]),
                        user_data["ips"],
                        human_readable_size(user_data["down"]),
                        human_readable_size(user_data["up"]),
                        human_readable_size(user_data["total"]),
                        usage_str,
                        human_readable_size(user_data["remaining"])
                    )
                
                console.print(table)
                console.print(f"[dim]Actualizado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}[/dim]")
                
                time.sleep(REFRESH_SECONDS)
                
            except KeyboardInterrupt:
                console.print("\n[bold yellow]Monitor detenido[/bold yellow]")
                break
            except Exception as e:
                console.print(f"[red]Error: {str(e)}[/red]")
                time.sleep(5)

if __name__ == "__main__":
    console.print("[bold green]Iniciando monitor combinado de VMESS...[/bold green]")
    console.print("Presiona Ctrl+C para salir\n")
    display_combined_stats()
